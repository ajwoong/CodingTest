# 또 dp 다. 그런데 이번엔 희망이 보인게 아이디어가 정말 다맞았다. 디테일의 부족이다.
# 이전 쉬운계단수에다가 이전 쉬운계단수의 맨 뒤숫자에다가 -1, +1을 하는 작업인데 0과 9처리를 어떻게 해야할지 몰랐다.
# 이럴때는 이전의 0과 9로 끝나는 애들까지 저장을 해두는 것이었다.
# dp 2차원 배열을 이용해, 끝나는 숫자가 0~9까지 에서 이전 쉬운계단수의 개수를 저장해두어서, 0일때는 이전 길이의 쉬운계단수중 끝이 1인거만큼 만들수있으니 그대로 가져오고, 
# 9 일때는 이전길이의 쉬운 게단 수중에서 8인거만큼 그대로 만들수 있으니 그대로 가져오고 이외의 경우는 예를들어 2일때라고 하면 이전 쉬운계단수에서 끝이 1일때나 3일때로 만들수 있으니
# 그 쉬운계단수들의 합으로 업데이트 한다.
# 디피 문제에 점점 감이 잡혀간다. 나는 할 수 있다.

n = int(input())

dp = [[ 0 for _ in range(10)] for _ in range(n+1)]

dp[1] = [0,1,1,1,1,1,1,1,1,1]

for i in range(2,len(dp)):
    for j in range(10):
        if(j==0):
            dp[i][j] = dp[i-1][j+1]
        elif(j==9):
            dp[i][j] = dp[i-1][j-1]
        else:
            dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]

print(sum(dp[n]) % 1000000000)