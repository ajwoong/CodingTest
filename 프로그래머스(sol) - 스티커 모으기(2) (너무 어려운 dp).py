# 또 너무 어려워서 푸는 방법조차 생각나지 않은 dp 문제이다
# dp를 너무 못푸는게 내 문제이다. dp를 잘 풀 수 있도록 계속 dp문제를 공부해야겠다
# 여기서는 스티커 0번, 혹은 스티커 1번을 떼는 경우 두가지로 나누어서 dp를 돌리는 문제였다
# 처음 뗀 스티커를 토대로 이후에 최대값 계산은 현재 값과 자기 인덱스 두 번 뒤의 합 값을 합한거(즉 지금 선택된 애를 떼는거)가 본인 전 인덱스, 즉 자기를 안뽑는 다른 선택과 비교했을 때 더 큰 것을 선택하는 방식이었다
# 그렇게 0번, 1번을 둘다 dp를 돌려서 더 큰 값을 선택하는 문제였다. 
# 사실 이렇게 나와서 잘 풀 수 있다는 자신이 좀 없다. 하지만 유형을 보고 dp구나. 정도는 깨달았다
# 앞으로 dp 문제가 나온다면, 더 오래 고민하고 점화식을 만들려는 버릇을 꼭 들여야겠다.

def solution(sticker):
    
    if(len(sticker) < 3):
        return max(sticker)
    
    dp1 = [0] + sticker[:-1]
    for i in range(2,len(dp1)):
        dp1[i] = max(dp1[i-1], dp1[i-2] + dp1[i])
        
    dp2 = [0] + sticker[1:]
    for i in range(2,len(dp2)):
        dp2[i] = max(dp2[i-1], dp2[i-2] + dp2[i])
    
                   
    return max(dp1[-1], dp2[-1])
        