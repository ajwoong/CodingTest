# 또 dp를 활용하는 문제였다.
# knapsack 문제로 유명한 문제이다.
# 이 문제는 배낭에 담을 수 있는 제한 무게 k에 최대가치를 넣는다면 어떻게 넣어야되는지에 대한 문제였다.
# 이제 이런 문제들에 대한 감이 잡히는게 현재 주어진걸 기준으로 넣어가면서 k에 맞추는게 아니라!
# k가 0부터 k까지를 구해가면서 업데이트 하는 거다.
# 이게 무슨말이냐면 dp[0]은 무게 제한이 0인 거중에서 최대가치 k이다
# dp[3]은 이문제에서 6이 될것이다. 무게 제한 3을 만드는건 [3,6] 짜리 밖에 없으니까
# 이런식으로 문제에서 구하고자하는건 무게 K가 제한일때인데, 우리는 k에 맞춰서 생각하는게 아니라 0,1,2,3,4.. k로 키워가며
# 구해간다는 느낌으로 가야한다. 디피 문제가 다 이런식이다
# dp[7]은 그래서 현재 dp[7]과 dp[7-3] + [3,6]이 주는 가치 중에서 더 큰 것을 고르는 것이다.
# 이런식으로 이전 dp[4] 4키로 제한에서 3키로 짜리가 들어왔을때 7키로 제한을 맞추니 그거를 구하는 식이다.
# 즉, 이전 최대값을 토대로 현재의 최대값을 구하는 것이다!!!!! 이전 최대값을 토대로 현재 최대값 이런식으로 dp를 하는것이다.

n, k = map(int,input().split())

item_list = []
for x in range(n):
    w, v = map(int,input().split())
    item_list.append([w,v])

dp = [0] * (k+1)

for item in item_list:
    for c in range(k,item[0] - 1, -1):
        dp[c] = max(dp[c], dp[c - item[0]] + item[1])

print(dp[k])